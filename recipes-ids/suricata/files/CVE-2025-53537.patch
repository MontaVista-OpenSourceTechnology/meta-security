From 9037ea35110a0d97be5cedf8d31fb4cd9a38c7a7 Mon Sep 17 00:00:00 2001 
From: Philippe Antoine <contact@catenacyber.fr> 
Date: Tue, 17 Jun 2025 10:12:47 +0200 
Subject: [PATCH] decompressors: fix leak in lzma error case

Ticket: 7766
--
From 226580d502ae98c148aaecc4846f78694b5e253c Mon Sep 17 00:00:00 2001
From: Philippe Antoine <contact@catenacyber.fr>
Date: Tue, 11 Mar 2025 16:45:35 +0100
Subject: [PATCH] decompressors: do not take data after end
--
From f8f41646099b92e9252776fdb28f180f0d30d6f9 Mon Sep 17 00:00:00 2001
From: Philippe Antoine <contact@catenacyber.fr>
Date: Tue, 16 Apr 2024 22:50:27 +0200
Subject: [PATCH] decompressor: only take erroneous data on first try

Ticket: 6959

We want to accept partial decompressed data with error, but only
if it is our first try, as we also want to try different
decompression algorithms if the first one does not match.

This led to use tolerating deflate which decompressed cleartext.


Upstream-Status: Backport from [https://github.com/OISF/libhtp/commit/9037ea35110a0d97be5cedf8d31fb4cd9a38c7a7, https://github.com/OISF/libhtp/commit/226580d502ae98c148aaecc4846f78694b5e253c, https://github.com/OISF/libhtp/commit/f8f41646099b92e9252776fdb28f180f0d30d6f9]
CVE: CVE-2025-53537
Signed-off-by: Milan Satpathy <msatpathy@mvista.com>
---
 htp/htp_core.h          |  5 ++++-
 htp/htp_decompressors.c | 23 ++++++++++++++---------
 2 files changed, 18 insertions(+), 10 deletions(-)

diff --git a/htp/htp_core.h b/htp/htp_core.h
index 780fcf1..71abdcd 100644
--- a/htp/htp_core.h
+++ b/htp/htp_core.h
@@ -158,7 +158,10 @@ enum htp_content_encoding_t {
     HTP_COMPRESSION_DEFLATE = 3,
 
     /** LZMA compression. */
-    HTP_COMPRESSION_LZMA = 4
+    HTP_COMPRESSION_LZMA = 4,
+
+    /** No more data. */
+    HTP_COMPRESSION_OVER = 5
 };
 
 /**
diff --git a/htp/htp_decompressors.c b/htp/htp_decompressors.c
index 4425089..10f0080 100644
--- a/htp/htp_decompressors.c
+++ b/htp/htp_decompressors.c
@@ -202,6 +202,8 @@ static htp_status_t htp_gzip_decompressor_decompress(htp_decompressor_gzip_t *dr
         }
 
         return HTP_OK;
+    } else if (drec->zlib_initialized == HTP_COMPRESSION_OVER) {
+        return HTP_ERROR;
     }
 
     if (d->data == NULL) {
@@ -315,15 +317,8 @@ restart:
             // no initialization means previous error on stream
             return HTP_ERROR;
         }
-        if (GZIP_BUF_SIZE > drec->stream.avail_out) {
-            if (rc == Z_DATA_ERROR) {
-                // There is data even if there is an error
-                // So use this data and log a warning
-                htp_log(d->tx->connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0, "GZip decompressor: inflate failed with %d", rc);
-                rc = Z_STREAM_END;
-            }
-        }
-        if (rc == Z_STREAM_END) {
+        int error_after_data = (rc == Z_DATA_ERROR && drec->restart == 0 && GZIP_BUF_SIZE > drec->stream.avail_out);
+        if (rc == Z_STREAM_END || error_after_data) {
             // How many bytes do we have?
             size_t len = GZIP_BUF_SIZE - drec->stream.avail_out;
 
@@ -350,6 +345,16 @@ restart:
             drec->stream.next_out = drec->buffer;
             // TODO Handle trailer.
 
+            if (error_after_data) {
+                // There is data even if there is an error
+                // So use this data and log a warning
+                htp_log(d->tx->connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0, "GZip decompressor: inflate failed with %d", rc);
+                if (drec->zlib_initialized == HTP_COMPRESSION_LZMA) {
+                    LzmaDec_Free(&drec->state, &lzma_Alloc);
+                }
+                drec->zlib_initialized = HTP_COMPRESSION_OVER;
+                return HTP_ERROR;
+            }
             return HTP_OK;
         }
         else if (rc != Z_OK) {
-- 
2.34.1

